/*
 * util/rconfig/rconfig.c
 * Copyright (C) 2017 Alexei Frolov
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include <dirent.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

#include <rconfig.h>

#include "gen.h"
#include "lint.h"
#include "parser.h"
#include "scanner.h"

static const char *src_dirs[] = { "kernel", "drivers", "lib", NULL };

#define NUM_SRC_DIRS   (sizeof src_dirs / sizeof (src_dirs[0]))
#define ARCH_DIR_INDEX (NUM_SRC_DIRS - 1)

int is_linting;
int exit_status;

void rconfig_set_archdir(const char *archdir)
{
	src_dirs[ARCH_DIR_INDEX] = archdir;
}

void rconfig_parse_file(const char *path, config_fn callback)
{
	yyscan_t rconfig_scanner;
	struct rconfig_file config;
	FILE *f;

	f = fopen(path, "r");
	if (!f) {
		perror(path);
		exit_status = 1;
		return;
	}

	config.name = NULL;
	config.path = path;
	config.alloc_size = 0;
	config.num_sections = 0;
	config.sections = NULL;

	yylex_init(&rconfig_scanner);
	yyset_in(f, rconfig_scanner);
	yyparse(rconfig_scanner, &config);
	yylex_destroy(rconfig_scanner);

	if (!is_linting)
		generate_config(&config, callback);

	free_rconfig(&config);

	fclose(f);
}

/*
 * rconfig_dir:
 * Recursively find all rconfig files in directory `path`.
 */
static void rconfig_dir(const char *path, config_fn callback)
{
	char dirpath[PATH_MAX];
	struct dirent *dirent;
	struct stat sb;
	int found_dir;
	DIR *d;

	d = opendir(path);
	if (!d)
		return;

	while ((dirent = readdir(d))) {
		if (strcmp(dirent->d_name, ".") == 0 ||
		    strcmp(dirent->d_name, "..") == 0)
			continue;

		found_dir = 0;
		if (dirent->d_type == DT_DIR) {
			snprintf(dirpath, PATH_MAX, "%s/%s",
			         path, dirent->d_name);
			found_dir = 1;
		} else if (dirent->d_type == DT_UNKNOWN) {
			snprintf(dirpath, PATH_MAX, "%s/%s",
			         path, dirent->d_name);
			if (stat(dirpath, &sb) != 0) {
				perror(dirpath);
				exit(1);
			}
			if (S_ISDIR(sb.st_mode))
				found_dir = 1;
		}

		if (found_dir) {
			rconfig_dir(dirpath, callback);
		} else if (strcmp(dirent->d_name, "rconfig") == 0) {
			snprintf(dirpath, PATH_MAX, "%s/rconfig", path);
			rconfig_parse_file(dirpath, callback);
		}
	}

	closedir(d);
}

void rconfig_recursive(config_fn callback)
{
	size_t i;

	rconfig_parse_file("rconfig", callback);

	for (i = 0; i < NUM_SRC_DIRS; ++i)
		rconfig_dir(src_dirs[i], callback);
}

/*
 * rconfig_concatenate:
 * Concatenate all partial rconfig files in CONFIG_DIR into
 * a single output file.
 */
int rconfig_concatenate(char *outfile)
{
	struct dirent *dirent;
	struct stat sb;
	char path[PATH_MAX];
	char buf[BUFSIZ];
	FILE *f, *out;
	int status;
	DIR *d;

	d = opendir(CONFIG_DIR);
	if (!d) {
		perror(CONFIG_DIR);
		return 1;
	}

	out = fopen(outfile, "w");
	if (!out) {
		perror(outfile);
		return 1;
	}

	fprintf(out, "#\n");
	fprintf(out, "# File automatically generated by rconfig "
	        PROGRAM_VERSION "\n");
	fprintf(out, "# Do not modify this file manually.\n");
	fprintf(out, "#\n");

	status = 0;
	while ((dirent = readdir(d))) {
		if (strncmp(dirent->d_name, ".rconfig.", 9) != 0)
			continue;

		snprintf(path, PATH_MAX, CONFIG_DIR "/%s", dirent->d_name);
		if (stat(path, &sb) != 0) {
			perror(path);
			status = 1;
			break;
		} else if (!S_ISREG(sb.st_mode)) {
			fprintf(stderr, "%s: not a regular file\n", path);
			status = 1;
			break;
		} else if (!(f = fopen(path, "r"))) {
			perror(path);
			status = 1;
			break;
		}

		fprintf(out, "\n\n");
		while (fgets(buf, BUFSIZ, f))
			fprintf(out, "%s", buf);

		fclose(f);
	}

	fclose(out);
	if (status == 1)
		unlink(outfile);
	closedir(d);

	return status;
}

/*
 * rconfig_verify_src_dirs:
 * Ensure that all source directories exist and are valid.
 * Returns 0 if successful, or an errno constant indicating the error that
 * occurred otherwise. The faulting directory is stored in `errdir`.
 */ 
int rconfig_verify_src_dirs(const char **errdir)
{
	struct stat sb;
	size_t i;

	if (stat("rconfig", &sb) != 0) {
		*errdir = "rconfig";
		return errno;
	} else if (S_ISDIR(sb.st_mode)) {
		*errdir = "rconfig";
		return EISDIR;
	} else if (access("rconfig", R_OK) != 0) {
		*errdir = "rconfig";
		return EACCES;
	}

	for (i = 0; i < NUM_SRC_DIRS; ++i) {
		*errdir = src_dirs[i];

		if (stat(src_dirs[i], &sb) == 0) {
			if (!S_ISDIR(sb.st_mode))
				return ENOTDIR;
			else if (access(src_dirs[i], R_OK) != 0)
				return EACCES;
			else
				continue;
		}
		if (i == ARCH_DIR_INDEX)
			return EINVAL;

		return errno;
	}

	*errdir = NULL;
	return 0;
}
